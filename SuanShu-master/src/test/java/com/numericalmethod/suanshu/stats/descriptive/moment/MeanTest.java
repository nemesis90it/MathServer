/*
 * Copyright (c) Numerical Method Inc.
 * http://www.numericalmethod.com/
 * 
 * THIS SOFTWARE IS LICENSED, NOT SOLD.
 * 
 * YOU MAY USE THIS SOFTWARE ONLY AS DESCRIBED IN THE LICENSE.
 * IF YOU ARE NOT AWARE OF AND/OR DO NOT AGREE TO THE TERMS OF THE LICENSE,
 * DO NOT USE THIS SOFTWARE.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITH NO WARRANTY WHATSOEVER,
 * EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
 * ANY WARRANTIES OF ACCURACY, ACCESSIBILITY, COMPLETENESS,
 * FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, NON-INFRINGEMENT,
 * TITLE AND USEFULNESS.
 * 
 * IN NO EVENT AND UNDER NO LEGAL THEORY,
 * WHETHER IN ACTION, CONTRACT, NEGLIGENCE, TORT, OR OTHERWISE,
 * SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
 * ANY CLAIMS, DAMAGES OR OTHER LIABILITIES,
 * ARISING AS A RESULT OF USING OR OTHER DEALINGS IN THE SOFTWARE.
 */
package com.numericalmethod.suanshu.stats.descriptive.moment;

import com.numericalmethod.suanshu.misc.R;
import com.numericalmethod.suanshu.stats.random.univariate.exp.InverseTransformSamplingExpRng;
import org.junit.Test;
import static org.junit.Assert.*;

/**
 *
 * @author Haksun Li
 */
public class MeanTest {

    /**
     * Test of class Mean.
     */
    @Test
    public void testMean_0010() {
        Mean stat = new Mean();

        //test initial computation
        stat.addData(R.seq(1d, 10d, 1d));
        assertEquals(5.5, stat.value(), 1e-15);
        assertEquals(10, stat.N());

        //test add a datum
        stat.addData(11d);
        assertEquals(6, stat.value(), 1e-15);
        assertEquals(11, stat.N());

        //test incremental computation
        stat.addData(R.seq(12d, 20d, 1d));
        assertEquals(10.5, stat.value(), 1e-15);
        assertEquals(20, stat.N());

        //test copy ctor
        Mean copy = new Mean(stat);
        assertEquals(10.5, copy.value(), 1e-15);
        assertEquals(20, copy.N());

        //should be same as incremental computation
        Mean single = new Mean(R.seq(1d, 20d, 1d));
        assertEquals(10.5, single.value(), 1e-15);
        assertEquals(20, single.N());
    }

    /**
     * Test of class Mean.
     * Data generated by rnorm in R.
     */
    @Test
    public void testMean_0020() {
        Mean stat = new Mean();

        //test initial computation
        stat.addData(new double[]{
                    -1.7977333841437806, -1.0369250374809862, 0.3576646172869447,
                    1.2297950522508387, -0.3980405847043308, -1.4283140839441753,
                    0.5943170533473481, 0.7851374981258880, 0.4987642139655898,
                    -0.9854474110741734, -0.4563279646286239, 1.6758835086294337,
                    -1.6436521974719591, 0.3464864103027401, 0.9576317484026332,
                    0.1978089068198400, 0.0685155985882378, -1.1301577036734154,
                    1.4355200984250092, -0.9489001118004204
                });
        assertEquals(-0.083898688638868, stat.value(), 1e-15);
        assertEquals(20, stat.N());

        //test add a datum
        stat.addData(10d);
        assertEquals(0.396286963201078, stat.value(), 1e-15);
        assertEquals(21, stat.N());

        //test incremental computation
        stat.addData(new double[]{
                    -0.42312519791388220, 2.47217216961963260, 1.02090789526838899,
                    0.14326109777800802, -0.42114733556251321, -2.16551888919980406,
                    -0.44754945521326350, 0.86415526297260536, -0.45780496809448112,
                    -0.21330133001220850, 0.15097176553253946, -1.37203549172738826,
                    -0.12808382301559926, -1.02097930231604450, 1.06121266199567343,
                    -0.70137808063507856, 2.16577141905987247, 0.00608961408051736,
                    -0.59994629414813194, -0.56166243222040058
                });
        assertEquals(0.187659402767587, stat.value(), 1e-15);
        assertEquals(41, stat.N());

        //test copy ctor
        Mean copy = new Mean(stat);
        assertEquals(0.187659402767587, copy.value(), 1e-15);
        assertEquals(41, copy.N());

        //should be same as incremental computation
        Mean single = new Mean(new double[]{
                    -1.7977333841437806, -1.0369250374809862, 0.3576646172869447,
                    1.2297950522508387, -0.3980405847043308, -1.4283140839441753,
                    0.5943170533473481, 0.7851374981258880, 0.4987642139655898,
                    -0.9854474110741734, -0.4563279646286239, 1.6758835086294337,
                    -1.6436521974719591, 0.3464864103027401, 0.9576317484026332,
                    0.1978089068198400, 0.0685155985882378, -1.1301577036734154,
                    1.4355200984250092, -0.9489001118004204,
                    10,
                    -0.42312519791388220, 2.47217216961963260, 1.02090789526838899,
                    0.14326109777800802, -0.42114733556251321, -2.16551888919980406,
                    -0.44754945521326350, 0.86415526297260536, -0.45780496809448112,
                    -0.21330133001220850, 0.15097176553253946, -1.37203549172738826,
                    -0.12808382301559926, -1.02097930231604450, 1.06121266199567343,
                    -0.70137808063507856, 2.16577141905987247, 0.00608961408051736,
                    -0.59994629414813194, -0.56166243222040058
                });
        assertEquals(0.187659402767587, single.value(), 1e-15);
        assertEquals(41, single.N());
    }

    /**
     * Test of class Mean.
     */
    @Test
    public void testMean_0030() {
        Mean stat = new Mean();
        assertEquals(Double.NaN, stat.value(), 1e-15);
        assertEquals(0, stat.N());
    }

    /**
     * Test of class Mean.
     */
    @Test
    public void testMean_0040() {
        int size = 5000000;

        Mean mean1 = new Mean();

        InverseTransformSamplingExpRng rng = new InverseTransformSamplingExpRng();
        double[] x = new double[size];
        for (int i = 0; i < size; ++i) {
            x[i] = rng.nextDouble();
            mean1.addData(x[i]);
        }

        Mean mean2 = new Mean(x);
        assertEquals(mean1.value(), mean2.value(), 1e-11);
    }
}
